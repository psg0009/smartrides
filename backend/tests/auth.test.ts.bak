import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { appRouter } from '../trpc/app-router';
import { prisma } from '../prisma';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

// Mock the modules
jest.mock('../prisma');
jest.mock('bcryptjs');
jest.mock('jsonwebtoken');

describe('Auth Router', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('signup', () => {
    it('should create a new user successfully', async () => {
      const mockUser = {
        id: 'user-1',
        name: 'John Doe',
        email: 'john@example.com',
        passwordHash: 'hashedPassword',
        role: 'student',
        university: 'Test University',
        verified: false,
        verificationStatus: 'none',
        rating: 0,
        avatar: null,
        stripeAccountId: null,
        stripeCustomerId: null,
        pushToken: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      (prisma.user.create as any).mockResolvedValue(mockUser);
      (bcrypt.hash as any).mockResolvedValue('hashedPassword');
      (jwt.sign as any).mockReturnValue('mock-jwt-token');

      const caller = appRouter.createCaller({
        req: {} as any,
        user: null,
        isAdmin: false,
      });

      const result = await caller.auth.signup({
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123',
        university: 'Test University',
      });

      expect(result).toEqual({
        user: {
          id: mockUser.id,
          name: mockUser.name,
          email: mockUser.email,
          role: mockUser.role,
          university: mockUser.university,
          verified: mockUser.verified,
          rating: mockUser.rating,
          avatar: mockUser.avatar,
        },
        token: expect.any(String),
      });

      expect(prisma.user.create).toHaveBeenCalledWith({
        data: {
          name: 'John Doe',
          email: 'john@example.com',
          passwordHash: expect.any(String),
          university: 'Test University',
          role: 'student',
        },
      });
    });

    it('should hash password correctly', async () => {
      const mockUser = {
        id: 'user-1',
        name: 'John Doe',
        email: 'john@example.com',
        passwordHash: 'hashedPassword',
        role: 'student',
        university: 'Test University',
        verified: false,
        verificationStatus: 'none',
        rating: 0,
        avatar: null,
        stripeAccountId: null,
        stripeCustomerId: null,
        pushToken: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      (prisma.user.create as any).mockResolvedValue(mockUser);
      (bcrypt.hash as any).mockResolvedValue('hashedPassword');
      (jwt.sign as any).mockReturnValue('mock-jwt-token');

      const caller = appRouter.createCaller({
        req: {} as any,
        user: null,
        isAdmin: false,
      });

      await caller.auth.signup({
        name: 'John Doe',
        email: 'john@example.com',
        password: 'password123',
        university: 'Test University',
      });

      expect(bcrypt.hash).toHaveBeenCalledWith('password123', 10);
    });

    it('should not allow duplicate emails', async () => {
      (prisma.user.create as any).mockRejectedValue(
        new Error('Unique constraint failed')
      );

      const caller = appRouter.createCaller({
        req: {} as any,
        user: null,
        isAdmin: false,
      });

      await expect(
        caller.auth.signup({
          name: 'John Doe',
          email: 'john@example.com',
          password: 'password123',
          university: 'Test University',
        })
      ).rejects.toThrow('User with this email already exists');
    });
  });

  describe('login', () => {
    it('should login user with valid credentials', async () => {
      const mockUser = {
        id: 'user-1',
        name: 'John Doe',
        email: 'john@example.com',
        passwordHash: 'hashedPassword',
        role: 'student',
        university: 'Test University',
        verified: true,
        verificationStatus: 'approved',
        rating: 5.0,
        avatar: null,
        stripeAccountId: null,
        stripeCustomerId: null,
        pushToken: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      (prisma.user.findUnique as any).mockResolvedValue(mockUser);
      (bcrypt.compare as any).mockResolvedValue(true);
      (jwt.sign as any).mockReturnValue('mock-jwt-token');

      const caller = appRouter.createCaller({
        req: {} as any,
        user: null,
        isAdmin: false,
      });

      const result = await caller.auth.login({
        email: 'john@example.com',
        password: 'password123',
      });

      expect(result).toEqual({
        user: {
          id: mockUser.id,
          name: mockUser.name,
          email: mockUser.email,
          role: mockUser.role,
          university: mockUser.university,
          verified: mockUser.verified,
          rating: mockUser.rating,
          avatar: mockUser.avatar,
        },
        token: expect.any(String),
      });
    });

    it('should reject login with invalid email', async () => {
      (prisma.user.findUnique as any).mockResolvedValue(null);

      const caller = appRouter.createCaller({
        req: {} as any,
        user: null,
        isAdmin: false,
      });

      await expect(
        caller.auth.login({
          email: 'nonexistent@example.com',
          password: 'password123',
        })
      ).rejects.toThrow('Invalid email or password');
    });

    it('should reject login with invalid password', async () => {
      const mockUser = {
        id: 'user-1',
        name: 'John Doe',
        email: 'john@example.com',
        passwordHash: 'hashedPassword',
        role: 'student',
        university: 'Test University',
        verified: true,
        verificationStatus: 'approved',
        rating: 5.0,
        avatar: null,
        stripeAccountId: null,
        stripeCustomerId: null,
        pushToken: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      (prisma.user.findUnique as any).mockResolvedValue(mockUser);
      (bcrypt.compare as any).mockResolvedValue(false);

      const caller = appRouter.createCaller({
        req: {} as any,
        user: null,
        isAdmin: false,
      });

      await expect(
        caller.auth.login({
          email: 'john@example.com',
          password: 'wrongpassword',
        })
      ).rejects.toThrow('Invalid email or password');
    });
  });
}); 